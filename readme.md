# 高级数据库课程设计报告

## 1. 课程设计概述

### 1.1. 选取论文

[Hyperion：Building the largest in-memory search tree（SIGMOD 2019）](http://dx.doi.org/10.1145/3299869.3319870)

### 1.2. 内容

对论文的实现。

## 2. 论文内容

论文基于当前已有的字典树，提出了一种新的内存数据库结构（Hyperion），以求提高空间效率，同时保证时间效率。

## 3. 论文实现

### 3.1. 数据结构

#### 3.1.1. 容器

容器的数据结构如下：

```c
	// 当前容纳的节点数量
	int size;
	// 跳表指针
	Container_pointers cptrs;
	// 容器中的节点
	Node<value_t> nodes[CONTAINER_SIZE];
```

容器的数据结构为固定大小，因此只使用一个size数据来表示容器使用情况；没有实现T-Node索引，因此也没有J位；所有的容器使用相同的S值作为分裂指标，因此没有S位。

#### 3.1.2. 节点

节点的数据结构如下：

```c
	// 指向数据
	value_t* value_ptr;
	// 指向的下一个目的地
	// 若为T-Node，则指向容器中的下一个T-Node；若为S-Node，则指向下一个容器。不存在时为NULL。
	Head_pointer* ptr;
	// 包含Node的标记信息
	char header;
	// Node存储的Key
	char c;
```

由于C++的数据对齐特性，因此对数据顺序进行重排，以减少节点的大小。
与论文相比，只使用了一位来判断是否为叶子节点。T-Node和S-Node为同一数据结构，具有相同的大小，使用delta-encoding会导致节点的大小不一，同时在频繁的插入、删除中，可能会因为delta-encoding的缘故需要在使用和不使用之前切换，从而对节点空间进行频繁的移动，造成额外的开销，因此没有delta-encoding位。
T-Node和S-Node为同一数据结构，均有指针数据，因此对T-Node默认使用js位，没有在header中使用。而jt代表的S-Node指针内容没有实现（出于数据结构一致而没有添加额外元素），因此在header中也没有jt位。

![](https://github.com/wind2009-louse/DBProject/doc/1.png)

图1 容器和节点的储存情况

#### 3.1.3. 点查询结果结构体

点查询结果的数据结构如下：

其中，result的可能取值如下：

```c
	#define PS_SEARCHING 0
	#define PS_SEARCHED 1
	#define PS_FAILED 2
```

#### 3.1.4. Hyperion Pointer(HP)

在代码中没有实现，原因如下：

- a. 使用5个字节的指针必然会导致能够对应的内存大小下降，为了尽量提高数据库可以使用的内存大小，没有对指针长度进行缩减（虽然论文中提到将指针长度从8字节降低到5字节，能够节省出不少空间。）
- b. 实现HP需要实现从HP到真实指针的映射，必然会有时间消耗，由于时间不够的原因，没能实现这一部分。

### 3.2. 数据库操作

#### 3.2.1. 插入/更新

从根容器开始，对key的前两位{k<sub>1</sub>, k<sub>2</sub>}进行前缀比较（分别在T-Node和S-Node）中比较。

##### 3.2.1.1. T-Node比较

从容器中的第一个T-Node开始往后查找。

* 查找到对应的T-Node t<sub>0</sub>，使k<sub>1</sub> = k<sub>t<sub>1</sub></sub>。若k_2=0，则在当前的T-Node进行插入/更新，否则对T-Node的S-Node进行前缀比较。

+ 查找到T-Node t<sub>1</sub>，使k<sub>t<sub>0</sub></sub> < k<sub>1</sub> < k<sub>t<sub>0</sub></sub>。在当前的T-Node进行插入/更新。

+ 查找到当前容器的末尾，仍然没有查找到T-Node t<sub>0</sub>，使k<sub>1</sub> < k<sub>t<sub>0</sub></sub>。此时判断当前容器是否为同一级中的最后一个容器。若是，则直接在当前容器中插入/更新，否则根据跳表信息找到同级中的下一个容器进行查找/更新。

##### 3.2.1.2. S-Node比较

在T-Node比较中，若找到了k<sub>1</sub> = k<sub>t<sub>1</sub></sub>，则进行S-Node的比较。

S-Node比较步骤和T-Node的比较步骤基本相同。

##### 3.2.1.3. 插入操作

插入操作的步骤如下：

- 移动

将容器中的节点向右移动1~2位，为将要插入的T-Node和S-Node腾出空间。此时，T-Node的指针需要进行修改，从而保证在移动后依旧能正确指向下一个T-Node。

- 插入

根据需要插入的内容，创建新的T-Node或S-Node，在腾出的空间中加入。

- 分裂

虽然代码中没有实现嵌入式容器，但由于容器较小，依旧存在需要分裂的情况。分裂后，通过跳表信息存储同一级中的其它容器的信息。

分裂指标如下：

~~size<sub>c</sub> >= a + b·s（论文中采取的分裂指标，由于没有实现嵌入式容器故不采用）~~

![](http://latex.codecogs.com/gif.latex?free_c\<\\frac{size_c}{8})

分裂时，将容器中的T-Node分成前后两份（分裂的指标保证分裂时容器中拥有至少两个T-Node），把后面的T-Node置入新容器中，同时更新T-Node的指针。

#### 3.2.2. 删除操作

删除操作也需要进行查找，通过查找到对应需要删除的内容，将其叶节点特征去除。若该节点无子容器/节点，说明该节点为最底层节点，开始沿着查询结果往上删除节点，直到回溯到一个叶节点为止（说明有数据存储在该节点中）。

删除操作是插入操作的逆操作，步骤如下：

- 移动

将容器中的节点左移1位（一次只删除1个节点），同时更新T-Node的指针。

- 容器删除

如果删除了当前容器中的最后一个节点，需要将该容器从同级容器列表中删除。此外，还需要将指向该容器的，上一级的S-Node的指针清空。

#### 3.3.3. 查找操作

##### 3.3.3.1. 点查询

Hyperion的点查询操作和常规的字典树一样，都是从顶层往下进行搜索。由于有跳表的存在，可以在同一级中取得比常规字典树更好的效率（O(logn)）。

##### 3.3.3.2. 范围查询

和字典树一样，Hyperion的范围查询也需要对节点进行遍历。

## 4. 测试

由于时间原因，没有具体测试性能，只确认基本确定功能能够正常运行。