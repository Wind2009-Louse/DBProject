# 高级数据库课程设计报告
- [高级数据库课程设计报告](#%e9%ab%98%e7%ba%a7%e6%95%b0%e6%8d%ae%e5%ba%93%e8%af%be%e7%a8%8b%e8%ae%be%e8%ae%a1%e6%8a%a5%e5%91%8a)
	- [1. 课程设计概述](#1-%e8%af%be%e7%a8%8b%e8%ae%be%e8%ae%a1%e6%a6%82%e8%bf%b0)
		- [1.1. 选取论文](#11-%e9%80%89%e5%8f%96%e8%ae%ba%e6%96%87)
		- [1.2. 内容](#12-%e5%86%85%e5%ae%b9)
	- [2. 论文内容](#2-%e8%ae%ba%e6%96%87%e5%86%85%e5%ae%b9)
	- [3. 论文实现](#3-%e8%ae%ba%e6%96%87%e5%ae%9e%e7%8e%b0)
		- [3.1. 数据结构](#31-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84)
			- [3.1.1. 容器](#311-%e5%ae%b9%e5%99%a8)
			- [3.1.2. 节点](#312-%e8%8a%82%e7%82%b9)
			- [3.1.3. 点查询结果结构体](#313-%e7%82%b9%e6%9f%a5%e8%af%a2%e7%bb%93%e6%9e%9c%e7%bb%93%e6%9e%84%e4%bd%93)
			- [3.1.4. Hyperion Pointer(HP)](#314-hyperion-pointerhp)
		- [3.2. 数据库操作](#32-%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c)
			- [3.2.1. 插入/更新](#321-%e6%8f%92%e5%85%a5%e6%9b%b4%e6%96%b0)
				- [3.2.1.1. T-Node比较](#3211-t-node%e6%af%94%e8%be%83)
				- [3.2.1.2. S-Node比较](#3212-s-node%e6%af%94%e8%be%83)
				- [3.2.1.3. 插入操作](#3213-%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c)
			- [3.2.2. 删除操作](#322-%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c)
			- [3.3.3. 查找操作](#333-%e6%9f%a5%e6%89%be%e6%93%8d%e4%bd%9c)
				- [3.3.3.1. 点查询](#3331-%e7%82%b9%e6%9f%a5%e8%af%a2)
				- [3.3.3.2. 范围查询](#3332-%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2)
	- [4. 测试](#4-%e6%b5%8b%e8%af%95)

## 1. 课程设计概述

### 1.1. 选取论文

[Hyperion：Building the largest in-memory search tree（SIGMOD 2019）](http://dx.doi.org/10.1145/3299869.3319870)

### 1.2. 内容

对论文的实现。

## 2. 论文内容

论文基于当前已有的字典树，提出了一种新的内存数据库结构（Hyperion），以求提高空间效率，同时保证时间效率。

## 3. 论文实现

### 3.1. 数据结构

#### 3.1.1. 容器

容器的数据结构如下：

```c++
	// 当前容纳的节点数量
	int size;
	// 跳表指针
	Container_pointers cptrs;
	// 容器中的节点
	Node<value_t> nodes[CONTAINER_SIZE];
```

容器的数据结构为固定大小，因此只使用一个size数据来表示容器使用情况；没有实现T-Node索引，因此也没有J位；所有的容器使用相同的分裂指标，因此没有S位。

#### 3.1.2. 节点

节点的数据结构如下：

```c++
	// 指向数据
	value_t* value_ptr;
	// 指向的下一个目的地
	// 若为T-Node，则指向容器中的下一个T-Node或者为NULL；若为S-Node，则指向下一个容器。不存在时为NULL。
	Head_pointer* ptr;
	// Node的标记信息
	char header;
	// Node存储的Key
	char c;
```

由于C++的数据对齐特性，因此对数据顺序进行了重排，以减少节点的大小。

与论文相比，只使用了一位来判断是否为叶子节点。T-Node和S-Node为同一数据结构，具有相同的大小，使用delta-encoding会导致节点的大小不一，同时在频繁的插入、删除中，可能会因为delta-encoding的缘故需要在使用和不使之间前切换，从而对节点空间进行频繁的移动，造成额外的开销，因此没有delta-encoding位。

T-Node和S-Node为同一数据结构，均有指针数据，因此对T-Node默认使用js位，没有在header中使用。而jt代表的S-Node指针内容没有实现（出于数据结构一致而没有添加额外数据），因此在header中也没有jt位。

![](https://github.com/Wind2009-Louse/DBProject/blob/master/doc/1.png?raw=true)

<center>图1 容器和节点的储存情况</center>

#### 3.1.3. 点查询结果结构体

点查询结果的数据结构如下：

其中，result的可能取值如下：

```c++
	// 正在查询中
	#define PS_SEARCHING 0
	// 查询结束，找到结果
	#define PS_SEARCHED 1
	// 查询结束，找不到结果
	#define PS_FAILED 2
```

#### 3.1.4. Hyperion Pointer(HP)

在代码中没有实现，原因如下：

- a. 使用5个字节的指针必然会导致能够对应的内存大小下降，为了尽量提高数据库可以使用的内存大小，没有对指针长度进行缩减（虽然论文中提到将指针长度从8字节降低到5字节，能够节省出不少空间。）
- b. 实现HP需要实现从HP到内存的映射，必然会有时间消耗，由于时间不够的原因，没能实现这一部分。

### 3.2. 数据库操作

#### 3.2.1. 插入/更新

从根容器开始，对key的前两位{k<sub>1</sub>, k<sub>2</sub>}进行前缀比较（分别在T-Node和S-Node）中比较。

##### 3.2.1.1. T-Node比较

从容器中的第一个T-Node开始往后查找。

* 查找到对应的T-Node t<sub>0</sub>，使k<sub>1</sub> = k<sub>t<sub>1</sub></sub>。若k_2=0，则在当前的T-Node进行插入/更新，否则对T-Node的S-Node进行前缀比较。

+ 查找到T-Node t<sub>1</sub>，使k<sub>t<sub>0</sub></sub> < k<sub>1</sub> < k<sub>t<sub>0</sub></sub>。在当前的T-Node进行插入/更新。

+ 查找到当前容器的末尾，仍然没有查找到T-Node t<sub>0</sub>，使k<sub>1</sub> < k<sub>t<sub>0</sub></sub>。此时判断当前容器是否为同一级中的最后一个容器。若是，则直接在当前容器中插入/更新，否则根据跳表信息找到同级中的下一个容器进行查找/更新。

##### 3.2.1.2. S-Node比较

在T-Node比较中，若找到了k<sub>1</sub> = k<sub>t<sub>1</sub></sub>，则进行S-Node的比较。

S-Node比较步骤和T-Node的比较步骤基本相同。

##### 3.2.1.3. 插入操作

插入操作的步骤如下：

+ 移动

  + 将容器中的节点向右移动1~2位，为将要插入的T-Node和S-Node腾出空间。此时，T-Node的指针需要进行修改，从而保证在移动后依旧能正确指向下一个T-Node。

+ 插入

  + 根据需要插入的内容，创建新的T-Node或S-Node，在腾出的空间中加入。

+ 分裂

  + 虽然代码中没有实现嵌入式容器，但由于容器较小，依旧存在需要分裂的情况。分裂后，通过跳表信息存储同一级中的其它容器的信息。

  ![](https://github.com/Wind2009-Louse/DBProject/blob/master/doc/2.png?raw=true)

  <center>图2 分裂示意图</center>

分裂指标如下：

~~<center>size<sub>c</sub> >= a + b·s（论文中采取的分裂指标，由于没有实现嵌入式容器故不采用）</center>~~

![](http://latex.codecogs.com/gif.latex?free_c%3C\frac{size_c}{8})

分裂时，将容器中的T-Node分成前后两份（分裂的指标保证分裂时容器中拥有至少两个T-Node），把后面的T-Node置入新容器中，同时更新T-Node的指针。

#### 3.2.2. 删除操作

删除操作也需要进行查找，通过查找到对应需要删除的内容，将其叶节点特征去除。若该节点无子容器/节点，说明该节点为最底层节点，开始沿着查询结果往上删除节点，直到回溯到一个叶节点为止（说明有数据存储在该节点中）。

删除操作是插入操作的逆操作，步骤如下：

- 移动

将容器中的节点左移1位（一次只删除T-Node或者S-Node），同时更新容器中T-Node的指针。

- 容器删除

如果删除了当前容器中的最后一个节点，需要将该容器从同级容器列表中删除。此外，还需要将指向该容器的，上一级的S-Node的指针置为NULL。

#### 3.3.3. 查找操作

##### 3.3.3.1. 点查询

Hyperion的点查询操作和常规的字典树一样，都是从顶层往下进行搜索。由于有跳表的存在，可以在同一级中取得比常规字典树更好的效率（O(logn)）。

##### 3.3.3.2. 范围查询

和字典树一样，Hyperion的范围查询也需要对节点进行遍历。

## 4. 测试

由于时间原因，没有具体测试性能，只确认基本确定功能能够正常运行，并以此为基础制作了简单的控制台。